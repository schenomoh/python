#!/usr/bin/python
####################################################
#
#  https://github.com/schenomoh/python
#
####################################################

# ./kudiff -p ../training/res/diff.param -r HELLO -1 ../training/res/media_library.csv -2 ../training/res/media_library.csv

### Sample param file ######
#[GLOBAL]
#DIR1=$HOME/APR/python
#DIR2=$HOME/APR/python
#
#[OVERRIDE]
#LOAD_DATE=2018-16-02
#
#[HELLO]
#FILE1=$DIR1/training/res/media_library.csv
#FILE2=$HOME/APR/python/training/res/media_library2.csv
#
#IGNORE_FIELD=load_id, LAST_UPDATE,
#COMPARE_FIELD=Main artist, Album, Track Id, 



import csv, io, sys, getopt, copy, ConfigParser, os
import traceback
#from inspect import currentframe, getframeinfo

def trace(message):
	print message

####################################################
# Returns the list of duplicated values
#
def get_duplicate(list):
	found=[]
	duplicate=[]
	for key in list:
		#If we discover a new value, put it in "found"
		#If the value was already found, it is a duplicate
		if key not in found:
			found.append(key)
		else:
			duplicate.append(key)
	return duplicate

####################################################
# Class to store the result
#
class resultClass:

	def __init__(self):
		self.record=[]

		currentdir=os.path.dirname(os.path.abspath(__file__))
		self.paramfile_path=currentdir+"/kudiff.param"
		self.dir1=currentdir
		self.dir2=currentdir
		
		self.file1_path=None
		self.file2_path=None
		self.compare_rule=None
		self.compare_key=None
		self.compare_ignore=None

	#Add a result at the end of the record[] array
	#def result(self, status, message, debug=""):
	#	self.record.append({'status':status, 'message':message, 'debug':[]})

	def success(self, message):
		self.record.append({'status':'SUCCESS', 'message':message, 'debug':[]})
	def failure(self, message):
		self.record.append({'status':'FAILURE', 'message':message, 'debug':[]})
	def warning(self, message):
		self.record.append({'status':'WARNING', 'message':message, 'debug':[]})
	def error(self, message):
		self.record.append({'status':'ERROR  ', 'message':message, 'debug':[]})
		self.bye()
	def bye(self, return_code=0):
		print self
		sys.exit(return_code)

	def extend(self, resultClass):
		self.record.extend(copy.deepcopy(resultClass.record))

	#Add a warning on the last result created
	def debug(self, debug):
		self.record[-1]['debug'].append(debug)

	#Pretty print of the resultClass
	def __str__(self):
		res=""
		for data in self.record:
			if res != "": res+="\n"
			res += str(data['status']) + " - " + str(data['message'])
			for w in data['debug']:
				res += "\n  DEBUG - "+str(w)
		return res

	#print override for python prompt
	def __repr__(self):
		return __str__(self)

####################################################
#Compare two argument lists and return a resultClass object
#
#def diff(list1, list2):
 #	res=resultClass()
 #	duplicate1=get_duplicate(list1)
 #	duplicate2=get_duplicate(list2)
 #
 #	if len(duplicate1) != 00 or len(duplicate2) != 00:
 #		res.failure("Duplicates found")
 #		res.debug( "Header1: " + str(duplicate1) )
 #		res.debug( "Header2: " + str(duplicate2) )
 #	else:
 #		res.success("No duplicate found")
 #	return res

####################################################
#
# Main
#

#----------------------------------------------------
# getopt fetch options from script arguments
# Remaining arguments are stored in args[:]

res=resultClass()

try:
        optlist, args = getopt.getopt(sys.argv[1:], 'p:r:1:2:', ['param=', 'rule=', 'file1=', 'file2=', 'separator='])
        if(len(sys.argv)==1):   raise ValueError('No argument')
except:
        print " Usage: " + sys.argv[0] +" [OPTIONS]"
        print "   -p, --param: param file location"
        print "   -r, --rule: section of the param file containing the comparaison rules"
        print "   -1, --file1: reference file for comparaison"
        print "   -2, --file1: file compared"
        sys.exit(2)


for opt, a in optlist:
        if opt in ('-p', '--param'):
        	res.paramfile_path= a
        if opt in ('-r', '--rule'):
        	res.compare_rule=a
        if opt in ('-1', '--file1'): res.file1_path=a
        if opt in ('-2', '--file2'): res.file2_path=a

#----------------------------------------------------
#Ensure valid param file name

res.paramfile_path=os.path.abspath(res.paramfile_path)
if not os.path.isfile(str(res.paramfile_path)):
	res.error("Unable to find param file " + res.paramfile_path)

#----------------------------------------------------
# Read param file
param = ConfigParser.ConfigParser()

param.read(res.paramfile_path)
if 'GLOBAL' not in param.sections():
	res.error("Unable to find [GLOBAL] section in param file: '"+res.paramfile_path+"'")

#Read directory aliases DIR1 and DIR2
if "dir1" in param.options('GLOBAL'):
	res.dir1=param.get('GLOBAL', 'DIR1')
if "dir2" in param.options('GLOBAL'):
	res.dir1=param.get('GLOBAL', 'DIR1')

#Ensure a section exist for the files to be compared
if res.compare_rule not in param.sections():
	res.error("Unable to find "+str(res.compare_rule)+" section in param file: '"+res.paramfile_path+"'")

res.file1_path = str.replace((str.replace(param.get(res.compare_rule, "FILE1"), "$DIR1", res.dir1)), "DIR2", res.dir2 )
res.file1_path = os.path.abspath(os.path.expandvars(res.file1_path))
res.file2_path = str.replace((str.replace(param.get(res.compare_rule, "FILE2"), "$DIR1", res.dir1)), "DIR2", res.dir2 )
res.file2_path = os.path.abspath(os.path.expandvars(res.file2_path))

#----------------------------------------------------
# Check the file dialects
try:

	file1=open(res.file1_path, 'rb')
	file2=open(res.file2_path, 'rb')

	dialect1 = csv.Sniffer().sniff(file1.read(5000))
	dialect2 = csv.Sniffer().sniff(file2.read(5000))

	file1.seek(0)
	file2.seek(0)

	csv1=csv.reader(file1, dialect1)
	csv2=csv.reader(file2, dialect2)

except Exception as e:
	res.error("Unable to open files to compare. "+ str(e))

#----------------------------------------------------
# Manage missmatching dialects
dialect1_values={'dialect':str(dialect1), 
	'delimiter':str(dialect1.delimiter),
	'doublequote':str(dialect1.doublequote),
	'escapechar':str(dialect1.escapechar),
	'lineterminator':str(dialect1.lineterminator),
	'quotechar':str(dialect1.quotechar),
	'quoting':str(dialect1.quoting),
	'skipinitialspace':str(dialect1.skipinitialspace)
}

dialect2_values={'dialect':str(dialect2), 
	'delimiter':str(dialect2.delimiter),
	'doublequote':str(dialect2.doublequote),
	'escapechar':str(dialect2.escapechar),
	'lineterminator':str(dialect2.lineterminator),
	'quotechar':str(dialect2.quotechar),
	'quoting':str(dialect2.quoting),
	'skipinitialspace':str(dialect2.skipinitialspace)
}

failureLogged=False
for key in dialect1_values:
	if dialect1_values[key] !=  dialect2_values[key]:
		if(not failureLogged):
			failureLogged=True
			res.failure("CSV dialect (format) missmatch")
		res.debug(str(key) + " is '"+str( dialect1_values[key])
		+ "' in file1 but '"+str( dialect2_values[key])+"' in file2")

if not failureLogged:
	res.success("CSV dialect (format) match")
del failureLogged

#----------------------------------------------------
# Manage header logic

for header1 in csv1:
	header1=[i.lower() for i in header1]
	break
for header2 in csv2:
	header2=[i.lower() for i in header2]
	break

#Ensure there is no duplicate in the header
if len(get_duplicate(header1)): res.error("Header 1 has duplicated fields: "+ str(get_duplicate(header1)))
if len(get_duplicate(header2)):	res.error("Header 2 has duplicated fields: "+ str(get_duplicate(header1)))

failureLogged=False
if header1 == header2:
	res.success("Header2 match")
elif header1[:len(header1)] == header2[:len(header1)]:
	res.warning("Header2 match with additional fields")
	res.debug("Additional fields: "+str(list(set(header2)-set(header1))))
elif len(set(header1) - set(header2))==0:
	failureLogged=True
	res.failure("Header2 order missmatch")
	res.debug("Header 1: "+ str(header1))
	res.debug("Header 2: "+ str(header2))
else:
	failureLogged=True
	res.failure("Header2 field name missmatch")
	res.debug("Missing in header2:" + str(list(set(header1)-set(header2))))
	res.debug("Missing in header1:" + str(list(set(header2)-set(header1))))

if failureLogged:
	res.error("Wrong headers, unable to continue")
del failureLogged

#Read the param file
try:
	compare_field=[i.strip().lower() for i in param.get(res.compare_rule, 'COMPARE_FIELD').split(',')]
	ignore_field=[i.strip().lower() for i in param.get(res.compare_rule, 'IGNORE_FIELD').split(',')]
except Exception as e:
	res.error(e)


#If the last compare key field is empty, then remove it
if compare_field[-1]=='':	compare_field=compare_field[:-1]

#Ensure all the compare key fields are available in the header file
if len(set(compare_field) - set(header1)) != 0:	res.error("Key fields are missing in header1: "+str(list(set(compare_field) - set(header1))))
if len(set(compare_field) - set(header2)) != 0:	res.error("Key fields are missing in header2: "+str(list(set(compare_field) - set(header2))))

#Store both field number and field name in the compare_key variable
compare_id=[header1.index(fieldName) for fieldName in compare_field]
compare_key=zip(compare_id, header1)
#Number of fields required to be able to retrive the compare key
required_fieldcount=max(compare_id)+1


#Fetch fields from files
#Do not forget header were already fetched
content1=[]
content2=[]


#Read all rows and ensure they contains the compare key
failureLogged=False
for record1 in csv1:
	if len(record1)>=required_fieldcount:
		content1.append(record1)
	else:
		#Ignore blank line
		if len(record1)==0: continue
		#Log error
		if(not failureLogged):
			failureLogged=True
			res.failure("Unable to fetch all rows from file1")
		res.debug("line " + str(csv1.line_num) + ": " + str(record1))

if not failureLogged:
	res.success("All rows fetched from file1")
del failureLogged

#Read all rows and ensure they contains the compare key
failureLogged=False
for record2 in csv2:
	if len(record2)>=required_fieldcount:
		content2.append(record2)
	else:
		#Ignore blank line
		if len(record2)==0: continue
		#Log error
		if(not failureLogged):
			failureLogged=True
			res.failure("Unable to fetch all rows from file2")
		res.debug("line " + str(csv2.line_num) + ": " + str(record2))

if not failureLogged:
	res.success("All rows fetched from file2")
del failureLogged

#Retrieve the key for a single input csv record
def get_key(record):
	out=[]
	#Dirty access to compare_key defined outside the function scope
	for id, name in compare_key:
		out.append(record[id])
	return out

#sort the content of my files
content1.sort(key=get_key)
content2.sort(key=get_key)

##----------------------------------------------------
#Loop on file1 and file2

#Variables required for the loop
last_cursor1=-1
last_cursor2=-1
cursor1=0
cursor2=0
last_key1=[]
key1=[]
last_key2=[]
key2=[]
i=0

#Variable to store results for later
duplicateFound=[]
unexpectedFound=[]


#Main loop
while (cursor1<len(content1) or cursor2<len(content2)):
	#print key1, key2

	#Fetch next file1 record and ensure it is not a duplicate
	if cursor1<len(content1) and last_cursor1 != cursor1 :
		key1=get_key(content1[cursor1])
		if last_key1 == key1:
			duplicateFound.append("Skipping duplicate in file1"+str(zip(compare_field,key1)))
			cursor1+=1
			continue

	#Fetch next file2 record and ensure it is not a duplicate
	if cursor2<len(content2) and last_cursor2 != cursor2:
		key2=get_key(content2[cursor2])
		if last_key2 == key2:
			duplicateFound.append("Skipping duplicate in file2"+str(zip(compare_field,key2))  )
			cursor2+=1
			continue

	#Store cursor position to identify moves
	last_cursor1=cursor1
	last_cursor2=cursor2

	#When the keys are matching, process the comparaison
	if key1 == key2:
		fieldNum=0
		missmatchingField=[]
		for field in content1[cursor1]:
			if header1[fieldNum] not in ignore_field:
				if field != content2[cursor2][fieldNum]:
					missmatchingField.append( str(header1[fieldNum]) + ": expecting '"+str(field) +"' instead of '"+ str(content2[cursor2][fieldNum]) +"'") 
			fieldNum+=1
		if missmatchingField==[]:
			res.success("Record match"+str(zip(compare_field,key1)) )
		else:
			res.failure("Record missmatch"+str(zip(compare_field,key1)) )
			for debugMessage in missmatchingField:
				res.debug(debugMessage)

		del missmatchingField
		cursor1+=1
		cursor2+=1
	#Key 1 not found. Log that and try next record of file1
	#OR we have reached the last record of file2 and we have to check the remaing file1 record
	if key1 < key2 or cursor2==len(content2):
		res.failure("Record not found in file2  "+str(zip(compare_field,key1)) ) 
		if cursor1 < len(content1):
			cursor1 += 1
		else:
			cursor2 += 1
	#Same as previous logic, but for the other file
	if key1 > key2 or cursor1==len(content1):
		unexpectedFound.append("Record not found in file1" + str(zip(compare_field,key2)) )
		if cursor2 < len(content2):
			cursor2 += 1
		else: 
			cursor1 += 1

	last_key1=key1[:]
	last_key2=key2[:]

	#Dummy logics to avoid infinite loop
	i+=1
	#if i>5:break
	#if i> len(content1) + len(content2) +10:
	#break




#Duplicate status
if duplicateFound == [] and  unexpectedFound == []:
	res.success("No unexpected record found")
else:
	res.failure("Unexpected records ")
	for i in duplicateFound:
		res.debug(i)
	for i in unexpectedFound:
		res.debug(i)


del cursor2, duplicateFound

res.bye()
