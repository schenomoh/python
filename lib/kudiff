#!/usr/bin/python3.4
#!/usr/bin/python
####################################################
#
#  https://github.com/schenomoh/python
#
####################################################

# ./kudiff -p ../training/res/diff.param -r HELLO -1 ../training/res/media_library.csv -2 ../training/res/media_library.csv

### Sample param file ######
#[GLOBAL]
#DIR1=$HOME/APR/python
#DIR2=$HOME/APR/python
#
#[OVERRIDE]
#LOAD_DATE=2018-16-02
#
#[HELLO]
#FILE1=$DIR1/training/res/media_library.csv
#FILE2=$HOME/APR/python/training/res/media_library2.csv
#
#IGNORE_FIELD=load_id, LAST_UPDATE,
#COMPARE_FIELD=Main artist, Album, Track Id, 



import csv, io, sys, getopt, copy, os
import configparser
import traceback
import json

#from inspect import currentframe, getframeinfo

def trace(message):
	print(message)

####################################################
# Returns the list of duplicated values
#
def get_duplicate(list):
	found=[]
	duplicate=[]
	for key in list:
		#If we discover a new value, put it in "found"
		#If the value was already found, it is a duplicate
		if key not in found:
			found.append(key)
		else:
			duplicate.append(key)
	return duplicate

####################################################
# Class to store the result
#
class resultClass:

	def __init__(self):
		self.record=[]
		self.tmpdetail=[]
		currentdir=os.path.dirname(os.path.abspath(__file__))
		self.paramfile_path=currentdir+"/kudiff.param"
		self.dir1=currentdir
		self.dir2=currentdir
		
		self.file1_path=None
		self.file2_path=None
		self.compare_rule=None
		self.compare_key=[]
		self.ignore_field=None

	#Add a result at the end of the record[] array
	#def result(self, status, message, detail=""):
	#	self.record.append({'status':status, 'message':message, 'detail':[]})

	def success(self, message):
		self.record.append({'status':'SUCCESS', 'message':message, 'detail':self.tmpdetail})
		self.tmpdetail=[]
	def failure(self, message):
		self.record.append({'status':'FAILURE', 'message':message, 'detail':self.tmpdetail})
		self.tmpdetail=[]
	def warning(self, message):
		self.record.append({'status':'WARNING', 'message':message, 'detail':[]})
		#self.tmpdetail=[]
	def error(self, message):
		self.record.append({'status':'ERROR  ', 'message':message, 'detail':self.tmpdetail})
		self.tmpdetail=[]
		self.bye()
	def bye(self, return_code=0):
		print(self)
		sys.exit(return_code)

	def extend(self, resultClass):
		self.record.extend(copy.deepcopy(resultClass.record))

	#Add a warning on the last result created
	def detail(self, detail):
		self.record[-1]['detail'].append(detail)

	def preparedetail(self, detail):
		self.tmpdetail.append(detail)

	#Pretty print of the resultClass
	def __str__(self):

		print("DEBUG   - " + self.compare_rule + " - file1_path = " + self.file1_path)
		print("DEBUG   - " + self.compare_rule + " - file2_path = " + self.file2_path)
		print("DEBUG   - " + self.compare_rule + " - compare_key = " + str(set(list(zip(*self.compare_key))[1] )) )
		print("DEBUG   - " + self.compare_rule + " - ignore_field = ", str(set(self.ignore_field)))

		res=""
		for data in self.record:
			if res != "": res+="\n"
			res += str(data['status']) + " - " + self.compare_rule + " - " + str(data['message'])
			for w in data['detail']:
				res += "\n "+data['status']+"_detail - "+ self.compare_rule + " - " +str(w)
		return res

	#print override for python prompt
	def __repr__(self):
		return __str__(self)

####################################################
#Compare two argument lists and return a resultClass object
#
#def diff(list1, list2):
 #	res=resultClass()
 #	duplicate1=get_duplicate(list1)
 #	duplicate2=get_duplicate(list2)
 #
 #	if len(duplicate1) != 00 or len(duplicate2) != 00:
 #		res.failure("Duplicates found")
 #		res.detail( "Header1: " + str(duplicate1) )
 #		res.detail( "Header2: " + str(duplicate2) )
 #	else:
 #		res.success("No duplicate found")
 #	return res

####################################################
#
# Main
#

#----------------------------------------------------
# getopt fetch options from script arguments
# Remaining arguments are stored in args[:]

res=resultClass()

try:
        optlist, args = getopt.getopt(sys.argv[1:], 'p:r:1:2:', ['param=', 'rule=', 'file1=', 'file2=', 'separator='])
        if(len(sys.argv)==1):   raise ValueError('No argument')
except:
        print(" Usage: " + sys.argv[0] +" [OPTIONS]")
        print("   -p, --param: param file location")
        print("   -r, --rule: section of the param file containing the comparaison rules")
        print("   -1, --file1: reference file for comparaison")
        print("   -2, --file1: file compared")
        sys.exit(2)


for opt, a in optlist:
        if opt in ('-p', '--param'):
        	res.paramfile_path= a
        if opt in ('-r', '--rule'):
        	res.compare_rule=a
        if opt in ('-1', '--file1'): res.file1_path=a
        if opt in ('-2', '--file2'): res.file2_path=a

#----------------------------------------------------
#Ensure valid param file name

res.paramfile_path=os.path.abspath(res.paramfile_path)
if not os.path.isfile(str(res.paramfile_path)):
	res.error("Unable to find param file " + res.paramfile_path)

#----------------------------------------------------
# Read param file
param = configparser.ConfigParser()

param.read(res.paramfile_path)
if 'GLOBAL' not in param.sections():
	res.error("Unable to find [GLOBAL] section in param file: '"+res.paramfile_path+"'")

#Read directory aliases DIR1 and DIR2
if "dir1" in param.options('GLOBAL'):
	res.dir1=param.get('GLOBAL', 'DIR1')
if "dir2" in param.options('GLOBAL'):
	res.dir1=param.get('GLOBAL', 'DIR1')

#Ensure a section exist for the files to be compared
if res.compare_rule not in param.sections():
	res.error("Unable to find "+str(res.compare_rule)+" section in param file: '"+res.paramfile_path+"'")

res.file1_path = str.replace((str.replace(param.get(res.compare_rule, "FILE1"), "$DIR1", res.dir1)), "DIR2", res.dir2 )
res.file1_path = os.path.abspath(os.path.expandvars(res.file1_path))
res.file2_path = str.replace((str.replace(param.get(res.compare_rule, "FILE2"), "$DIR1", res.dir1)), "DIR2", res.dir2 )
res.file2_path = os.path.abspath(os.path.expandvars(res.file2_path))

#----------------------------------------------------
# Check the file dialects
try:

	file1=open(res.file1_path, 'r')
	file2=open(res.file2_path, 'r')
	dialect1 = csv.Sniffer().sniff(file1.read(2000))
	dialect2 = csv.Sniffer().sniff(file2.read(2000))
	file1.seek(0)
	file2.seek(0)
except:
	del(file1)
	del(file2)

	try:
		file1=open(res.file1_path, 'r')
		file2=open(res.file2_path, 'r')
		dialect1 = csv.Sniffer().sniff(file1.read(50))
		dialect2 = csv.Sniffer().sniff(file2.read(50))
		file1.seek(0)
		file2.seek(0)
	except Exception as e:
		res.error("Unable to open the csv files "+ str(e))

try:
	csv1=csv.reader(file1, dialect1)
	csv2=csv.reader(file2, dialect2)
except Exception as e:
	res.error("Unable to read csv files "+ str(e))

#----------------------------------------------------
# Manage missmatching dialects
dialect1_values={'dialect':str(dialect1), 
	'delimiter':str(dialect1.delimiter),
	'doublequote':str(dialect1.doublequote),
	'escapechar':str(dialect1.escapechar),
	'lineterminator':str(dialect1.lineterminator),
	'quotechar':str(dialect1.quotechar),
	'quoting':str(dialect1.quoting),
	'skipinitialspace':str(dialect1.skipinitialspace)
}

dialect2_values={'dialect':str(dialect2), 
	'delimiter':str(dialect2.delimiter),
	'doublequote':str(dialect2.doublequote),
	'escapechar':str(dialect2.escapechar),
	'lineterminator':str(dialect2.lineterminator),
	'quotechar':str(dialect2.quotechar),
	'quoting':str(dialect2.quoting),
	'skipinitialspace':str(dialect2.skipinitialspace)
}

checkFailed=False
for key in dialect1_values:
	if dialect1_values[key] !=  dialect2_values[key]:
		checkFailed=True
		res.preparedetail("CSV dialect missmatch. " + str(key) + " is '"+str( dialect1_values[key])
		+ "' in file1 but '"+str( dialect2_values[key])+"' in file2")

#----------------------------------------------------
# Manage header logic

for header1 in csv1:
	header1=[i.lower() for i in header1]
	break
for header2 in csv2:
	header2=[i.lower() for i in header2]
	break

#Ensure there is no duplicate in the header
if len(get_duplicate(header1)): res.error("Header 1 has duplicated fields: "+ str(get_duplicate(header1)))
if len(get_duplicate(header2)):	res.error("Header 2 has duplicated fields: "+ str(get_duplicate(header1)))


if header1 == header2:
	res.success("Header2 match")
elif header1[:len(header1)] == header2[:len(header1)]:
	res.warning("Header2 match with additional fields")
	res.detail("Additional fields: "+str(list(set(header2)-set(header1))))
elif len(set(header1) - set(header2))==0:
	checkFailed=True
	res.failure("Header2 order missmatch")
	res.detail("Header 1: "+ str(header1))
	res.detail("Header 2: "+ str(header2))
else:
	checkFailed=True
	res.failure("Header2 field name missmatch")
	res.detail("Missing in header2:" + str(list(set(header1)-set(header2))))
	res.detail("Missing in header1:" + str(list(set(header2)-set(header1))))

if checkFailed:
	res.error("Wrong headers, unable to continue")

#Read the param file
try:
	compare_field=[i.strip().lower() for i in param.get(res.compare_rule, 'COMPARE_FIELD').split(',')]
	res.ignore_field=[i.strip().lower() for i in param.get(res.compare_rule, 'IGNORE_FIELD').split(',')]
except Exception as e:
	res.error(e)


#If the last compare key field is empty, then remove it
if compare_field[-1]=='':	compare_field=compare_field[:-1]

#Ensure all the compare key fields are available in the header file
if len(set(compare_field) - set(header1)) != 0:	res.error("Key fields are missing in header1: "+str(list(set(compare_field) - set(header1))))
if len(set(compare_field) - set(header2)) != 0:	res.error("Key fields are missing in header2: "+str(list(set(compare_field) - set(header2))))

#Store both field number and field name in the compare_key variable
res.compare_id=[header1.index(fieldName) for fieldName in compare_field]
#res.compare_key=list(zip(res.compare_id, header1))
i=0
for i in range(0,len(compare_field)):
	res.compare_key.append((res.compare_id[i], compare_field[i]))

#Number of fields required to be able to retrive the compare key
required_fieldcount=max(res.compare_id)+1


#Fetch fields from files
#Do not forget header were already fetched
content1=[]
content2=[]


#Read all rows and ensure they contains the compare key
for record1 in csv1:
	if len(record1)>=required_fieldcount:
		content1.append(record1)
	else:
		#Ignore blank line
		if len(record1)==0: continue
		#Log error
		checkFailed=True
		res.preparedetail("File1, Missing compare key for " + str(csv1.line_num) + ": " + str(record1))

#Read all rows and ensure they contains the compare key
for record2 in csv2:
	if len(record2)>=required_fieldcount:
		content2.append(record2)
	else:
		#Ignore blank line
		if len(record2)==0: continue
		#Log error
		checkFailed=True
		res.preparedetail("File2, Missing compare key for " + str(csv2.line_num) + ": " + str(record2))

if checkFailed:
	res.failure("File format missmatch")
else:
	res.success("File format match")
del checkFailed
checkFailed=False

#Retrieve the key for a single input csv record
def get_key(record, prettyPrint=False):

	if not prettyPrint:
		out=[]
		#Dirty access to compare_key defined outside the function scope
		for id, name in res.compare_key:
			out.append(record[id])
		return out
	else:
		out={}
		#Dirty access to compare_key defined outside the function scope
		for id, name in res.compare_key:
			out[name]=record[id]
		return str(out)

#sort the content of my files
content1.sort(key=get_key)
content2.sort(key=get_key)



#----------------------------------------------------
#Remove duplicate in file 1

i=0
while len(content1) > i+1:
	if get_key(content1[i]) == get_key(content1[i+1]):
		checkFailed=True
		res.preparedetail("File 1 duplicate skipped "+get_key(content1[i], True))
		del(content1[i])
		i=i-1
	i=i+1


#----------------------------------------------------
#Remove duplicate in file 2

i=0
while len(content2) > i+1:
	if get_key(content2[i]) == get_key(content2[i+1]):
		checkFailed=True
		res.preparedetail("File 2 duplicate skipped "+get_key(content2[i], True))
		del(content2[i])
		i=i-1
	i=i+1

if checkFailed:
	res.failure("Duplicate records found")
else:
	res.success("No duplicate records in file")


unexpected=[]
#----------------------------------------------------
#Loop on file1
while len(content1) > 0 and len(content2) > 0 :
	key1=get_key(content1[0])
	key2=get_key(content2[0])
	if key1 < key2:
		res.failure("missing record in file2" + get_key(content1[0], True))
		del content1[0]
	elif key1 > key2:
		unexpected.append(get_key(content1[0], True))
		del content2[0]
	else:
		#Process the field comparaison
		fieldNum=0
		checkFailed=False
		for field in content1[0]:
			if header1[fieldNum] not in res.ignore_field:
				if field != content2[0][fieldNum]:
					checkFailed=True
					res.preparedetail( "File 1 {'" + str(header1[fieldNum]) +"': " + str(field) +"}" )
					res.preparedetail( "File 2 {'"+ str(header1[fieldNum])  +"': " + str(content2[0][fieldNum])+"}" )
			fieldNum+=1
		if checkFailed:
			res.failure("Missmatching values " + get_key(content1[0], True))
		else:
			res.success("Record values match " + get_key(content1[0], True) )
		del checkFailed

		del content1[0]
		del content2[0]

print(len(content1), len(content2))

checkFailed=False
#----------------------------------------------------
#Trailing missing records from file1
for record in content1:
	checkFailed=True
	res.preparedetail("File1 record missing in file2: " + get_key(record, True))

#----------------------------------------------------
#Trailing unexpected records in file2
for record in content2:
	checkFailed=True
	unexpected.append(get_key(record))
if unexpected != []:
	checkFailed=True
	for detail in unexpected:
		res.preparedetail("Unexpected file 2 record: " + str(detail))


if checkFailed:
	res.failure("Record list missmatch")
else:
	res.success("Record list match")


res.bye()